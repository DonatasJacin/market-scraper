#!/usr/bin/env python3
import requests
import time
import re
import json
import os
import random
from dataclasses import dataclass
from typing import Optional, List, Dict, Set
from urllib.parse import quote
from typing import List, Dict, Optional, Tuple


# ============================================================
#  Case Hardened Blue Gem Scanner (All Knives)
#  - All wears, StatTrak + non-StatTrak
#  - Steam HTML + local CSGOFloat (per-item GET)
#  - Discord webhook notifications
#  - Runs indefinitely with pauses between scans
#  - Avoids duplicate notifications for the same listing_id
#    (persisted via JSON between runs)
# ============================================================

# --------- 0. Config: Steam cookies + Discord webhook ---------
# Get these from your browser devtools (Application/Storage -> Cookies -> steamcommunity.com)
STEAM_COOKIES = {
    "steamLoginSecure": "",
    "sessionid": "",
}

# Discord webhook URL for notifications
DISCORD_WEBHOOK_URL = ""

# This is what will appear as the mention. For a guaranteed ping,
# you can change this to your user ID in the form "<@123456789012345678>".
DISCORD_MENTION = "@Donatas"

# File to persist seen listing IDs between runs
SEEN_HITS_FILE = "seen_hits.json"

session = requests.Session()
session.cookies.update(STEAM_COOKIES)

# Keep track of listing_ids we've already notified about
SEEN_HIT_LISTING_IDS: Set[str] = set()

# --------- JSON cache helpers for seen listing IDs ---------

def load_seen_hit_ids() -> None:
    """Load seen listing IDs from JSON file into SEEN_HIT_LISTING_IDS."""
    global SEEN_HIT_LISTING_IDS
    if not os.path.exists(SEEN_HITS_FILE):
        print("[i] No seen_hits.json cache found, starting fresh.")
        return

    try:
        with open(SEEN_HITS_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        if isinstance(data, list):
            SEEN_HIT_LISTING_IDS = set(str(x) for x in data)
            print(f"[i] Loaded {len(SEEN_HIT_LISTING_IDS)} seen listing IDs from cache.")
        else:
            print("[!] seen_hits.json has unexpected format, ignoring.")
    except Exception as e:
        print(f"[!] Failed to load seen hits cache: {e}")


def save_seen_hit_ids() -> None:
    """Persist SEEN_HIT_LISTING_IDS to JSON file."""
    try:
        with open(SEEN_HITS_FILE, "w", encoding="utf-8") as f:
            json.dump(sorted(SEEN_HIT_LISTING_IDS), f)
        print(f"[i] Saved {len(SEEN_HIT_LISTING_IDS)} seen listing IDs to cache.")
    except Exception as e:
        print(f"[!] Failed to save seen hits cache: {e}")


# --------- 1. Knife list & Blue Gem pattern config ---------

# All Case Hardened knives we want to scan
BASE_KNIFE_NAMES: List[str] = [
    "★ Kukri Knife | Case Hardened",
    "★ Skeleton Knife | Case Hardened",
    "★ Nomad Knife | Case Hardened",
    "★ Survival Knife | Case Hardened",
    "★ Paracord Knife | Case Hardened",
    "★ Classic Knife | Case Hardened",
    "★ Talon Knife | Case Hardened",
    "★ Stiletto Knife | Case Hardened",
    "★ Ursus Knife | Case Hardened",
    "★ Navaja Knife | Case Hardened",
    "★ Bowie Knife | Case Hardened",
    "★ Shadow Daggers | Case Hardened",
    "★ Falchion Knife | Case Hardened",
    "★ Butterfly Knife | Case Hardened",
    "★ Huntsman Knife | Case Hardened",
    "★ Karambit | Case Hardened",
    "★ M9 Bayonet | Case Hardened",
    "★ Bayonet | Case Hardened",
    "★ Flip Knife | Case Hardened",
    "★ Gut Knife | Case Hardened",
]

# Doppler knives to scan
DOPPLER_KNIFE_NAMES = [
    "★ Bayonet | Doppler",
    "★ Shadow Daggers | Doppler",
    "★ Ursus Knife | Doppler",
    "★ Falchion Knife | Doppler",
    "★ Gut Knife | Doppler",
    "★ Huntsman Knife | Doppler",
    "★ Bowie Knife | Doppler",
    "★ Flip Knife | Doppler",
    "★ Paracord Knife | Doppler",
    "★ Navaja Knife | Doppler",
    "★ Survival Knife | Doppler",
    "★ Skeleton Knife | Doppler",
]

# Doppler only drops in FN / MW in practice, so limit exteriors a bit
DOPPLER_EXTERIORS = [
    "Factory New",
    "Minimal Wear",
]

# Finish catalog → Doppler finish name
DOPPLER_FINISH_BY_CATALOG = {
    415: "Ruby",     # Doppler Ruby
    416: "Sapphire", # Doppler Sapphire
    419: "Phase 2",  # Doppler Phase 2
    417: "Black Pearl"
    # you can add others later (Phase 1, Black Pearl, etc.)
}

# Marble Fade Fire & Ice knives to scan (keys of MARBLE_FADE_PATTERNS)
MARBLE_FADE_KNIFE_NAMES = [
    "★ Bayonet | Marble Fade",
    "★ Karambit | Marble Fade",
    "★ Talon Knife | Marble Fade",
    "★ Flip Knife | Marble Fade",
    "★ Gut Knife | Marble Fade",
]

# Fire & Ice realistically only appears FN / MW
MARBLE_FADE_EXTERIORS = [
    "Factory New",
    "Minimal Wear",
]

# Gamma Doppler Emerald-capable knives
GAMMA_DOPPLER_KNIFE_NAMES = [
    "★ Bayonet | Gamma Doppler",
    "★ Flip Knife | Gamma Doppler",
    "★ Gut Knife | Gamma Doppler",
    "★ Karambit | Gamma Doppler",
    "★ M9 Bayonet | Gamma Doppler",
    "★ Huntsman Knife | Gamma Doppler",
    "★ Falchion Knife | Gamma Doppler",
    "★ Bowie Knife | Gamma Doppler",
    "★ Butterfly Knife | Gamma Doppler",
    "★ Shadow Daggers | Gamma Doppler",
]

# Emeralds only drop FN/MW
GAMMA_DOPPLER_EXTERIORS = [
    "Factory New",
    "Minimal Wear",
]


# For each knife, we have tiers 1–3.
# (All your pattern data here, unchanged)
BLUE_GEM_PATTERNS: Dict[str, Dict[int, set[int]]] = {
    "★ Kukri Knife | Case Hardened": {
        1: {494, 575, 770, 652, 618, 917, 844, 112, 891, 838, 868, 510, 330, 631, 985, 808},  # Tier 1 patterns here
        2: {130, 283, 335, 721, 798, 702, 841, 371, 38, 881, 638, 811, 643, 682, 61},  # Tier 2 patterns here
        3: {468, 664, 182, 629, 989, 488, 334, 823, 426, 282, 73, 515, 694, 547, 916, 858, 749, 854, 630, 499, 375, 256, 442, 961, 116, 919, 306, 902, 853, 522, 776, 411, 92, 809, 262, 612, 885, 505, 398, 528, 194, 576, 711, 642, 883, 768, 708, 34, 414, 347, 657, 14, 713, 74, 698, 453, 273, 89, 188, 457, 98, 907, 616, 800, 42, 263, 243, 244, 175, 318, 305, 134, 281},  # Tier 3 patterns here
    },
    "★ Skeleton Knife | Case Hardened": {
        1: {403, 681, 456, 169, 681, 316, 577, 58, 468, 14, 497, 557, 180, 56, 640, 961, 447, 702, 862, 127, 577, 643, 985},
        2: {704, 55, 281, 922, 668, 449, 556, 351, 447, 583, 262, 180, 880, 210, 345, 850, 648, 698, 383, 820, 501, 60, 776, 55, 516, 618, 130, 80, 567, 347, 116, 854, 850, 13, 547, 853, 79, 50, 623, 495, 599, 236, 849, 631, 223, 700, 916, 902, 334, 879, 442, 844, 87, 157},
        3: {634, 124, 601, 496, 170, 915, 585, 916, 67, 628, 383, 239, 698, 372, 533, 336, 588, 442, 202, 837, 166, 116, 700, 954, 187, 797, 429, 632, 529, 516, 157, 547, 14, 294, 103, 525, 624, 503, 434, 73, 941, 363, 53, 662, 858, 525, 317, 693, 955, 823, 780, 188, 10, 883, 556, 798, 609, 707, 891, 429, 241, 134, 488, 374, 917, 576, 344, 345, 126, 470, 542, 170, 262, 335, 863, 278, 938, 77, 731, 940, 299, 636, 636, 690, 890, 179, 291, 766, 874, 61, 729, 616, 491, 563, 153, 689, 438, 829, 935, 766, 620, 144, 140, 213, 922, 81, 809, 450},
    },
    "★ Nomad Knife | Case Hardened": {
        1: {577, 456, 169, 681, 55, 403, 922, 704, 316, 850, 628, 187, 668},
        2: {447, 281, 210, 700, 180, 588, 262, 13, 336, 880, 383, 429, 698, 797, 14, 496, 525, 634, 166, 529, 442, 872, 583, 103, 632, 585, 624, 955, 294, 558, 723},
        3: {170, 372, 58, 387, 345, 286, 10, 179, 828, 151, 915, 879, 853, 449, 902, 533, 202, 393, 640, 818, 916, 935, 363, 940, 556, 954, 750, 168, 648, 516, 719, 776, 239, 235, 325, 887, 227, 212, 91, 351, 298, 680, 740, 502, 261, 369, 144, 689, 189, 310, 649, 619, 938, 606, 560, 806, 532, 450, 641, 84, 526, 124},
    },
    "★ Survival Knife | Case Hardened": {
        1: {403, 456, 169, 681, 316, 577, 281, 634, 585, 583},
        2: {704, 922, 55, 449, 668, 351, 601, 447, 210, 850, 628, 880, 556, 180, 58},
        3: {170, 372, 166, 915, 797, 202, 632, 496, 533, 262, 67, 336, 588, 187, 345, 239, 837, 624, 103, 383, 529, 700, 698, 157, 179, 288, 430, 887, 393, 429, 954, 916, 349, 812, 867, 286, 162, 387, 872, 516},
    },
    "★ Paracord Knife | Case Hardened": {
        1: {403, 316, 456, 58, 681, 577, 169, 583, 585, 634, 449},
        2: {922, 704, 601, 281, 345, 180, 55, 351, 239, 668, 447, 383, 288, 166},
        3: {837, 210, 880, 430, 915, 628, 850, 556, 372, 503, 170, 349, 202, 525, 496, 262, 67, 116, 269, 336, 533, 632, 588, 959, 797, 529, 187, 176, 374, 417, 954, 88, 157, 916, 507, 669, 910, 812, 899},
    },
    "★ Classic Knife | Case Hardened": {
        1: {403, 449, 585, 58, 681, 169, 456, 601, 316, 577, 634, 281},
        2: {704, 922, 55, 583, 288, 668, 107, 166, 606, 651, 910, 946},
        3: {210, 351, 837, 915, 880, 556, 628, 345, 850, 202, 239, 447, 372, 67, 170, 336, 417, 632, 496, 533, 529, 887, 262, 503, 393, 162, 269, 954, 383, 797, 867, 180, 374, 157, 588, 537, 916, 624, 103, 187, 812, 179, 698, 91, 818, 941, 519, 294, 516, 235, 227, 619, 689, 526, 504, 551, 715, 680, 167},
    },
    "★ Talon Knife | Case Hardened": {
        1: {55, 923, 241, 819, 602, 899, 222, 528, 10, 837, 185, 3, 311, 805, 387, 74, 905, 713, 450, 770, 575, 321, 112, 453, 139, 34, 868, 661, 310, 306},
        2: {316, 180, 14, 80, 114, 351, 866, 873, 176, 170, 199, 805, 299, 357, 56, 609, 501, 707, 468, 657, 379, 365, 283, 506, 576, 570, 473, 976, 621, 186, 505, 815, 960, 293, 622, 721, 82, 670, 888, 442, 463, 842, 698, 236, 775, 426, 470, 216, 92, 955, 978, 32, 256, 711, 4, 147, 605, 985, 849, 179, 950, 708, 809, 541, 13, 429, 935, 961, 151, 189, 122, 517},
        3: {95, 203, 891, 367, 19, 533, 941, 693, 374, 658, 18, 111, 130, 137, 291, 669, 660, 883, 599, 328, 749, 488, 491, 761, 798, 58, 46, 830, 345, 583, 807, 116, 278, 375, 494, 497, 242, 862, 168, 690, 202, 788, 592, 509, 648, 627, 205, 37, 322, 182, 917, 798, 965, 856, 228, 284, 341, 155, 844, 323, 695, 580, 25, 248, 597, 259, 578, 777, 485, 746, 875, 945, 953, 557, 42, 308},
    },
    "★ Stiletto Knife | Case Hardened": {
        1: {182, 398, 928, 407, 965, 838, 371, 749, 838, 214, 283, 330, 913, 494},
        2: {74, 713, 917, 868, 92, 453, 322, 112, 798, 891, 664},
        3: {263, 721,321, 139, 488, 905, 522, 803, 387, 269, 638, 147, 420, 73, 463, 256, 809, 29, 510, 782, 442, 928, 130, 375, 853, 964, 273, 839, 208, 242, 335, 244, 776, 330, 788, 507, 11, 919, 82, 282, 470, 358, 332, 341, 670, 694, 194, 248, 811, 842, 770, 632, 720, 478, 846},
    },
    "★ Ursus Knife | Case Hardened": {
        1: {494, 770, 618, 575, 917, 652, 112, 891},
        2: {838, 283, 130, 844, 702, 721, 868, 881, 468, 510, 798, 371, 330, 488, 631, 643, 808, 811, 694, 638},
        3: {664, 858, 907, 576, 61, 841, 248, 38, 182, 749, 528, 854, 961, 73, 505, 334, 306, 989, 823, 630, 116, 56, 426, 916, 612, 985, 411, 547, 375, 883, 657, 282, 14, 188, 442, 919, 658, 902, 776, 522, 108, 853, 347, 414, 256, 642, 305},
    },
    "★ Navaja Knife | Case Hardened": {
        1: {398, 407, 838, 371, 182, 839, 638, 720, 74, 749, 919, 713, 913},
        2: {401, 273, 877, 332, 598, 453, 283, 928, 139, 965, 773, 282, 902, 515, 420, 975, 891, 322, 335, 989, 30, 424, 797, 809, 811, 463, 782, 798, 635, 358, 917, 510, 194, 694, 974, 265, 808, 284, 490, 460},
        3: {632, 73, 67, 889, 507, 793, 664, 387, 269, 776, 846, 92, 853, 256, 377, 522, 214, 330, 847, 905, 136, 727, 341, 185, 868, 630, 655, 642, 29, 418, 494, 942, 499, 884, 466, 615, 32, 432, 595},
    },
    "★ Bowie Knife | Case Hardened": {
        1: {182, 398},
        2: {652, 29, 838, 371, 358, 638, 214, 928, 208, 768, 913, 714, 43, 944, 396, 534},
        3: {839, 720, 283, 282, 749, 147, 858, 330, 407, 629, 713, 964, 919, 74, 917, 868, 335, 782, 499, 902, 965, 256, 989, 891, 598, 457, 494, 885, 924, 515, 414, 846, 612, 466, 753, 767, 642, 399, 478, 263, 628, 872, 987, 474, 110, 880},
    },
    "★ Shadow Daggers | Case Hardened": {
        1: {56, 505, 417, 609, 657, 576, 707, 80, 14, 618, 468},
        2: {176, 830, 866, 406, 702, 4, 859, 59, 130, 355, 897, 883, 780, 249},
        3: {602, 771, 367, 346, 601, 365, 241, 180, 553, 156, 881, 88, 445, 283, 379, 55, 64, 357, 887, 819, 564, 351, 347, 550, 891, 497, 269, 488, 441, 3, 640, 366, 654, 188, 584, 319, 961, 401, 706, 10},
    },
    "★ Falchion Knife | Case Hardened": {
        1: {494, 838, 638, 891, 371, 917, 868, 112, 130, 330, 798, 575, 694, 194, 664, 488},
        2: {283, 749, 182, 398, 721, 770, 919, 652, 881, 522, 38, 214, 885, 964, 989, 902, 841, 73, 547, 282, 630, 631, 809, 510, 803, 116, 335, 92, 965, 499, 426, 42, 717, 322, 244, 800, 711, 655, 407, 776, 453, 913, 262, 42, 713},
        3: {823, 811, 256, 74, 768, 854, 808, 916, 844, 453, 411, 618, 375, 924, 273, 893, 839, 598, 642, 928, 702, 334, 414, 528, 846, 269, 905, 175, 826, 254, 767, 263, 106, 432, 708, 985, 61, 89, 332, 341, 515, 20, 643, 265, 470},
    },
    "★ Butterfly Knife | Case Hardened": {
        1: {182, 494, 194, 283, 694, 703, 838, 891, 913, 917},
        2: {29, 194, 214, 263, 283, 330, 371, 396, 398, 478, 488, 494, 510, 612, 638, 652, 694, 703, 717, 749, 800, 868, 881, 891, 913, 917, 928},
        3: {27, 38, 42, 43, 61, 72, 73, 78, 92, 98, 112, 130, 147, 256, 282, 318, 320, 335, 358, 407, 411, 424, 426, 457, 458, 474, 499, 515, 534, 618, 628, 629, 642, 643, 655, 664, 702, 705, 711, 721, 767, 768, 770, 782, 798, 799, 808, 811, 839, 846, 858, 872, 885, 902, 907, 913, 919, 924, 958, 964, 965},
    },
    "★ Huntsman Knife | Case Hardened": {
        1: {618, 652, 29},
        2: {721, 770, 494, 702, 838, 881, 505, 891, 306, 638, 798, 248, 576, 283, 112, 371, 917, 130, 575, 703, 510, 488, 330},
        3: {56, 73, 707, 868, 919, 108, 72, 844, 182, 428, 458, 153, 629, 255, 741, 927, 858, 749, 631, 6, 694, 457, 194},
    },
    "★ Karambit | Case Hardened": {
        1: {387, 73, 269, 442, 463, 510, 776, 809, 853, 888, 905, 417, 406, 150, 550, 897, 601, 346, 503, 59},
        2: {34, 74, 82, 130, 150, 152, 236, 256, 262, 303, 321, 322, 346, 375, 377, 406, 413, 453, 494, 503, 507, 509, 541, 550, 601, 643, 661, 698, 727, 770, 811, 823, 828, 914, 955, 156, 885, 553, 546, 249, 859, 366, 355, 4, 915, 269, 915, 400, 303, 269, 315, 354, 138, 246, 654, 253, 975},
        3: {9, 11, 20, 25, 30, 57, 59, 92, 112, 138, 139, 154, 179, 182, 216, 246, 265, 273, 282, 306, 310, 323, 330, 341, 366, 400, 426, 429, 450, 490, 499, 515, 530, 553, 575, 580, 631, 655, 664, 670, 711, 713, 721, 798, 838, 841, 844, 849, 852, 856, 891, 917, 965, 989, 88, 924, 715, 887, 959, 986, 374, 430, 445, 293, 835, 349, 117, 610, 195, 401, 610, 195, 598, 570, 706, 345, 413, 507, 517, 356, 866, 564, 671, 205, 530, 630, 176, 476, 908, 473, 650, 821, 613, 878, 803, 675, 813},
    },
    "★ M9 Bayonet | Case Hardened": {
        1: {601, 58, 150, 239, 349, 403, 406, 417, 503, 523, 585, 634, 675, 897},
        2: {21, 91, 107, 117, 166, 167, 202, 224, 253, 269, 281, 288, 336, 346, 354, 355, 366, 430, 449, 517, 550, 613, 628, 715, 793, 813, 867, 880, 946},
        3: {4, 41, 59, 88, 108, 124, 141, 157, 173, 204, 210, 227, 229, 243, 249, 286, 293, 295, 298, 319, 345, 356, 372, 393, 476, 490, 525, 529, 533, 546, 553, 598, 610, 790, 821, 837, 859, 866, 887, 908, 910, 915, 933, 959},
    },
    "★ Bayonet | Case Hardened": {
        1: {555, 151, 179, 228, 321, 592, 617, 661, 670, 695, 760, 828, 955},
        2: {168, 209, 228, 321, 387, 661, 695, 760, 828, 955, 969},
        3: {4, 13, 82, 103, 112, 137, 202, 281, 325, 363, 430, 493, 512, 532, 537, 617, 678, 710, 715, 733, 750, 790, 791, 797, 823, 844, 868, 872, 887, 894, 905, 922, 996},
    },
    # Existing Flip Knife patterns kept as-is
    "★ Flip Knife | Case Hardened": {
        1: {670, 321, 151, 592, 661, 555},  # Tier 1
        2: {828, 955, 179, 387, 844, 168, 868, 363, 791, 750, 823, 103, 760},  # Tier 2
        3: {996, 969, 905, 169, 695, 532, 577, 879, 770, 733, 715, 209, 872, 526, 456, 13, 681, 430, 189, 112, 887, 689, 28, 628, 228, 137, 878, 922, 4, 768, 479, 961, 690, 278, 429, 325},  # Tier 3
    },
    "★ Gut Knife | Case Hardened": {
        1: {567, 962, 125, 60, 647},
        2: {165, 799, 140, 171, 591, 215, 977, 723, 997, 644, 870, 724, 232, 939, 384, 974, 730, 218, 662, 920, 9, 928},
        3: {756, 50, 40, 477, 729, 971, 836, 86, 691, 552, 540, 388, 953, 245, 466, 272, 776, 758, 510, 795, 639, 428, 922, 549},
    },
}


DOPPLER_PATTERNS = {
    "Bayonet": {
        "ruby": {
            "tier1": [273, 353, 3, 902],
            "tier2": [760, 23, 162, 187, 189, 226, 269, 624, 916, 955],
            "tier3": [2, 34, 57, 63, 97, 118, 142, 145, 179, 187, 189, 222, 256, 271, 276, 277, 298, 387, 445, 532, 549, 568, 630, 633, 665, 667, 693, 719, 725, 801, 851, 860, 863, 924, 931, 942, 955, 977],
        },
        "sapphire": {
            "tier1": [273, 353, 3, 902],
            "tier2": [760, 23, 162, 187, 189, 226, 269, 624, 916, 955],
            "tier3": [2, 34, 57, 63, 97, 118, 142, 145, 179, 187, 189, 222, 256, 271, 276, 277, 298, 387, 445, 532, 549, 568, 630, 633, 665, 667, 693, 719, 725, 801, 851, 860, 863, 924, 931, 942, 955, 977],
        },
        "phase2": {
            "tier1": [15, 35, 159, 200, 239, 261, 350, 355, 417, 474, 495, 542, 565, 585, 603, 623, 682, 704, 748, 755, 833, 986, 987],
            "tier2": [19, 25, 55, 56, 83, 86, 101, 134, 144, 192, 199, 225, 226, 245, 248, 264, 305, 306, 316, 317, 346, 349, 371, 410, 419, 421, 434, 443, 501, 503, 544, 560, 562, 581, 618, 620, 625, 634, 635, 644, 671, 707, 713, 778, 814, 847, 877, 927, 938, 970, 973],
            "tier3": [13, 36, 45, 65, 118, 148, 174, 185, 207, 214, 219, 258, 264, 301, 330, 343, 367, 379, 394, 415, 439, 451, 479, 492, 504, 512, 532, 549, 584, 616, 617, 641, 645, 654, 676, 694, 716, 738, 741, 757, 760, 769, 843, 870, 886, 889, 903, 920, 945, 947, 967],
        },
    },

    "Shadow Daggers": {
        "ruby": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "sapphire": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "phase2": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
    },

    "Ursus Knife": {
        "ruby": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "sapphire": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "phase2": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
    },

    "Falchion Knife": {
        "ruby": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "sapphire": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "phase2": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
    },

    "Gut Knife": {
        "ruby": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "sapphire": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "phase2": {
            "tier1": [34, 41, 87, 93, 105, 205, 256, 326, 341, 348, 380, 403, 422, 449, 468, 494, 517, 520, 521, 527, 550, 571, 575, 576, 577, 583, 601, 636, 648, 651, 664, 668, 714, 742, 763, 807, 834, 848, 892, 897, 910, 911, 925, 943, 944, 961, 975],
            "tier2": [11, 29, 46, 84, 107, 136, 137, 141, 147, 150, 201, 224, 236, 278, 308, 345, 375, 395, 396, 399, 401, 428, 455, 465, 486, 597, 599, 639, 657, 690, 703, 712, 745, 747, 751, 754, 781, 789, 793, 800, 824, 825, 827, 838, 840, 849, 856, 872, 914, 936, 956, 968, 981],
            "tier3": [21, 30, 43, 64, 73, 80, 89, 130, 145, 168, 172, 173, 181, 211, 223, 229, 249, 260, 282, 283, 295, 313, 314, 358, 377, 381, 430, 435, 447, 458, 462, 466, 482, 488, 508, 511, 514, 525, 536, 566, 568, 572, 608, 640, 665, 677, 686, 726, 749, 759, 798, 813, 881, 891, 917, 940],
        },
    },

    "Huntsman Knife": {
        "ruby": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "sapphire": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "phase2": {
            "tier1": [7, 39, 59, 72, 77, 106, 119, 153, 166, 190, 194, 209, 244, 259, 265, 279, 286, 290, 360, 369, 374, 383, 408, 409, 419, 423, 432, 443, 469, 502, 526, 574, 594, 595, 600, 638, 646, 650, 659, 720, 816, 839, 857, 859, 861, 893, 896, 913, 951, 954, 969, 983, 999],
            "tier2": [13, 20, 24, 49, 66, 88, 96, 113, 116, 134, 160, 174, 189, 193, 217, 218, 220, 226, 235, 237, 250, 284, 303, 325, 373, 394, 425, 450, 464, 477, 480, 492, 498, 504, 529, 531, 532, 552, 560, 610, 616, 627, 680, 689, 699, 711, 715, 716, 730, 739, 744, 750, 783, 820, 843, 852, 865, 871, 919, 926, 935, 973, 992, 998],
            "tier3": [4, 31, 42, 44, 45, 54, 75, 83, 102, 115, 132, 142, 143, 162, 184, 185, 221, 231, 248, 253, 262, 269, 280, 296, 311, 317, 349, 352, 355, 371, 384, 386, 387, 398, 410, 434, 436, 451, 484, 490, 507, 510, 523, 540, 544, 547, 551, 558, 579, 598, 603, 611, 634, 642, 675, 678, 684, 693, 694, 721, 731, 733, 767, 772, 784, 853, 855, 883, 890, 928, 939, 986],
        },
    },

    "Bowie Knife": {
        "ruby": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "sapphire": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "phase2": {
            "tier1": [18, 23, 79, 104, 117, 118, 157, 176, 179, 187, 277, 289, 298, 299, 323, 376, 389, 392, 416, 446, 528, 584, 645, 658, 740, 752, 757, 758, 760, 769, 774, 806, 808, 821, 835, 851, 866, 886, 895, 921, 933, 955, 974, 984, 990, 991, 993, 995],
            "tier2": [6, 12, 22, 33, 37, 37, 47, 76, 94, 154, 191, 210, 212, 227, 276, 285, 293, 302, 324, 336, 361, 392, 424, 433, 433, 442, 446, 458, 487, 487, 513, 538, 564, 586, 587, 587, 612, 687, 698, 698, 719, 762, 782, 790, 811, 811, 815, 815, 860, 863, 863, 875, 878, 887, 898, 915, 953, 960, 979, 979, 161, 442],
            "tier3": [21, 30, 43, 64, 73, 80, 103, 109, 130, 145, 155, 172, 173, 181, 211, 223, 229, 249, 260, 282, 283, 295, 313, 314, 358, 377, 381, 429, 435, 440, 447, 462, 466, 481, 482, 488, 508, 511, 514, 525, 536, 566, 568, 572, 597, 608, 640, 665, 677, 686, 726, 759, 813, 881, 891, 917, 940],
        },
    },

    "Flip Knife": {
        "ruby": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "sapphire": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "phase2": {
            "tier1": [7, 39, 59, 72, 77, 106, 119, 153, 166, 190, 194, 209, 244, 259, 265, 279, 286, 290, 360, 369, 374, 383, 408, 409, 419, 423, 432, 443, 469, 502, 526, 574, 594, 595, 600, 638, 646, 650, 659, 720, 816, 839, 857, 859, 861, 893, 896, 913, 951, 954, 969, 983, 999],
            "tier2": [13, 20, 24, 49, 66, 88, 96, 113, 116, 134, 160, 174, 189, 193, 217, 218, 220, 226, 235, 237, 250, 284, 303, 325, 373, 394, 425, 450, 464, 477, 480, 492, 498, 504, 529, 531, 532, 552, 560, 610, 616, 627, 680, 689, 699, 711, 715, 716, 730, 739, 744, 750, 783, 820, 843, 852, 865, 871, 919, 926, 935, 973, 992, 998],
            "tier3": [4, 31, 42, 44, 45, 54, 75, 83, 102, 115, 132, 142, 143, 162, 184, 185, 221, 231, 248, 253, 262, 269, 280, 296, 311, 317, 349, 352, 355, 371, 384, 386, 387, 398, 410, 434, 436, 451, 484, 490, 507, 510, 523, 540, 544, 547, 551, 558, 579, 598, 603, 611, 634, 642, 675, 678, 684, 693, 694, 721, 731, 733, 767, 772, 784, 853, 855, 883, 890, 928, 939, 986],
        },
    },

    "Paracord Knife": {
        "ruby": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "sapphire": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "phase2": {
            "tier1": [16, 48, 126, 129, 146, 152, 182, 204, 230, 241, 252, 281, 292, 332, 344, 359, 393, 412, 457, 522, 541, 578, 602, 607, 628, 649, 652, 660, 673, 685, 688, 701, 705, 736, 743, 773, 777, 780, 787, 792, 832, 874, 908, 918, 923, 988, 994],
            "tier2": [5, 8, 14, 32, 58, 108, 112, 178, 188, 202, 213, 233, 243, 274, 337, 340, 356, 378, 405, 406, 444, 452, 454, 461, 471, 493, 539, 614, 621, 631, 653, 683, 696, 702, 728, 732, 761, 770, 795, 803, 826, 854, 867, 873, 876, 922, 949, 959, 966, 971, 982, 997, 1000],
            "tier3": [28, 68, 90, 121, 149, 156, 165, 171, 177, 195, 206, 232, 238, 287, 329, 351, 370, 372, 402, 441, 499, 516, 545, 546, 553, 559, 561, 589, 590, 591, 632, 637, 655, 656, 672, 706, 725, 727, 753, 756, 764, 766, 785, 791, 805, 809, 810, 817, 818, 844, 858, 868, 941, 972, 976, 977],
        },
    },

    "Navaja Knife": {
        "ruby": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "sapphire": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "phase2": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
    },

    "Skeleton Knife": {
        "ruby": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "sapphire": {
            "tier1": [628],
            "tier2": [],
            "tier3": [],
        },
        "phase2": {
            "tier1": [16, 48, 126, 129, 146, 152, 182, 204, 230, 241, 252, 281, 292, 332, 344, 359, 393, 412, 457, 522, 541, 578, 602, 607, 628, 649, 652, 660, 673, 685, 688, 701, 705, 736, 743, 773, 777, 780, 787, 792, 832, 874, 908, 918, 923, 988, 994],
            "tier2": [5, 8, 14, 32, 58, 108, 112, 178, 188, 202, 213, 233, 243, 274, 337, 340, 356, 378, 405, 406, 444, 452, 454, 461, 471, 493, 539, 614, 621, 631, 653, 683, 696, 702, 728, 732, 761, 770, 795, 803, 826, 854, 867, 873, 876, 922, 949, 959, 966, 971, 982, 997, 1000],
            "tier3": [28, 68, 90, 121, 149, 156, 165, 171, 177, 195, 206, 232, 238, 287, 329, 351, 370, 372, 402, 441, 499, 516, 545, 546, 553, 559, 561, 589, 590, 591, 632, 637, 655, 656, 672, 706, 725, 727, 753, 756, 764, 766, 785, 791, 805, 809, 810, 817, 818, 844, 858, 868, 941, 972, 976, 977],
        },
    },

    "Survival Knife": {
        "ruby": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "sapphire": {
            "tier1": [],
            "tier2": [],
            "tier3": [],
        },
        "phase2": {
            "tier1": [16, 48, 126, 129, 146, 152, 182, 204, 230, 241, 252, 281, 292, 332, 344, 359, 393, 412, 457, 522, 541, 578, 602, 607, 628, 649, 652, 660, 673, 685, 688, 701, 705, 736, 743, 773, 777, 780, 787, 792, 832, 874, 908, 918, 923, 988, 994],
            "tier2": [5, 8, 14, 32, 58, 108, 112, 178, 188, 202, 213, 233, 243, 274, 337, 340, 356, 378, 405, 406, 444, 452, 454, 461, 471, 493, 539, 614, 621, 631, 653, 683, 696, 702, 728, 732, 761, 770, 795, 803, 826, 854, 867, 873, 876, 922, 949, 959, 966, 971, 982, 997, 1000],
            "tier3": [28, 68, 90, 121, 149, 156, 165, 171, 177, 195, 206, 232, 238, 287, 329, 351, 370, 372, 402, 441, 499, 516, 545, 546, 553, 559, 561, 589, 590, 591, 632, 637, 655, 656, 672, 706, 725, 727, 753, 756, 764, 766, 785, 791, 805, 809, 810, 817, 818, 844, 858, 868, 941, 972, 976, 977],
        },
    },
}

MARBLE_FADE_PATTERNS = {
    "★ Bayonet | Marble Fade": {
        "fire_and_ice": {
            "max1": [412],
            "max2": [541, 241, 16, 649, 701, 602, 359, 688, 146, 393],
            "max3": [628, 792, 152, 777, 994, 344, 292, 281, 743, 673],
            "max4": [780, 48, 923, 126, 908, 129, 874, 787, 332, 918],
            "max5": [988, 252, 652, 660, 705, 457, 685, 832, 578, 522, 182, 204, 736],
            "max6": [873, 112, 761, 982, 452, 471, 773, 444, 230, 621, 631, 356, 340, 876, 607],
        },
    },

    "★ Karambit | Marble Fade": {
        "fire_and_ice": {
            "max1": [412],  # 1st Max
            "max2": [16, 146, 241, 359, 393, 541, 602, 649, 688, 701],
            "max3": [152, 281, 292, 344, 628, 673, 743, 777, 792, 994],
            "max4": [48, 126, 129, 332, 780, 787, 874, 908, 918, 923],
            "max5": [182, 204, 252, 457, 522, 578, 652, 660, 685, 705, 736, 832, 988],
            "max6": [112, 230, 340, 356, 444, 452, 471, 607, 621, 631,
                     761, 773, 873, 876, 982],
            "max7": [8, 14, 32, 58, 108, 213, 233, 243, 274, 405, 454, 614,
                     653, 683, 728, 732, 770, 795, 803, 826, 867, 949],
            "max8": [5, 178, 188, 202, 337, 378, 406, 461, 539, 696, 702,
                     854, 966, 971],
            "max9": [68, 121, 149, 165, 171, 206, 287, 370, 493, 499,
                     516, 637, 655, 656, 672, 706, 766, 817, 922, 959, 997],
            "max10": [28, 156, 177, 238, 402, 545, 546, 553, 559, 589, 591,
                      725, 764, 791, 810, 844, 858, 868, 972, 977],
        },
        "max_fake": [
            9, 27, 90, 110, 125, 183, 195, 203, 232, 254,
            329, 351, 372, 397, 404, 441, 448, 459, 473, 483,
            537, 561, 590, 626, 632, 647, 710, 727, 753, 756,
            785, 805, 809, 818, 869, 909, 930, 941, 962, 976,
            980, 989,
        ],
        "fake_fire_and_ice": [
            60, 62, 71, 98, 148, 170, 196, 216, 222, 234,
            266, 304, 307, 309, 315, 321, 328, 333, 364, 368,
            400, 411, 413, 415, 438, 445, 463, 485, 489, 496,
            506, 535, 570, 582, 593, 605, 630, 663, 667, 670,
            674, 691, 717, 723, 746, 794, 822, 845, 846, 931,
            948, 958,
        ],
    },

    "★ Talon Knife | Marble Fade": {
        "fire_and_ice": {
            "max1": [763],
            "max2": [93, 326, 341, 403, 468, 575, 636, 897, 910, 961],
            "max3": [41, 87, 348, 520, 521, 527, 601, 651, 714, 911],
            "max4": [34, 205, 256, 576, 583, 668, 742, 807, 892, 944],
            "max5": [105, 380, 422, 517, 550, 571, 648, 664, 834, 848, 925, 943, 975],
            "max6": [107, 147, 201, 399, 428, 449, 494, 577, 745, 747,
                     800, 824, 825, 936, 981],
            "max7": [29, 84, 150, 224, 278, 345, 375, 395, 396, 486, 639,
                     690, 751, 754, 793, 827, 840, 856, 872, 914, 956, 968],
            "max8": [11, 46, 137, 141, 236, 308, 401, 465, 599, 657,
                     781, 789, 838, 849],
            "max9": [80, 136, 181, 229, 313, 314, 358, 435, 455, 462, 482,
                     572, 597, 608, 640, 703, 712, 726, 813, 881, 917],
            "max10": [21, 43, 64, 130, 145, 172, 173, 223, 249, 282, 283,
                      381, 447, 466, 511, 514, 566, 665, 759, 891, 940],
        },
    },

    "★ Flip Knife | Marble Fade": {
        "fire_and_ice": {
            "max1": [412],
            "max2": [16, 146, 241, 359, 393, 541, 602, 649, 688, 701],
            "max3": [152, 281, 292, 344, 628, 673, 743, 777, 792, 994],
            "max4": [48, 126, 129, 332, 780, 787, 874, 908, 918, 923],
            "max5": [182, 204, 252, 457, 522, 578, 652, 660, 685, 705,
                     736, 832, 988],
            "max6": [112, 230, 340, 356, 444, 452, 471, 607, 621, 631,
                     761, 773, 873, 876, 982],
            "max7": [8, 14, 32, 58, 108, 213, 233, 243, 274, 405, 454,
                     614, 653, 683, 728, 732, 770, 795, 803, 826, 867, 949],
            "max8": [5, 178, 188, 202, 337, 378, 406, 461, 539, 696,
                     702, 854, 966, 971],
            "max9": [68, 121, 149, 165, 171, 206, 287, 370, 493, 499,
                     516, 637, 655, 656, 672, 706, 766, 817, 922, 959, 997],
            "max10": [28, 156, 177, 238, 402, 545, 546, 553, 559, 589,
                      591, 725, 764, 791, 810, 844, 858, 868, 972, 977],
        },
        "fake_fire_and_ice": [
            9, 27, 90, 110, 125, 183, 195, 203, 232, 254, 329, 351,
            372, 397, 404, 441, 448, 459, 473, 483, 537, 561, 590,
            626, 632, 647, 710, 727, 753, 756, 785, 805, 809, 818,
            869, 909, 930, 941, 962, 976, 980, 989,
        ],
    },

    "★ Gut Knife | Marble Fade": {
        "fire_and_ice": {
            "max1": [412],
            "max2": [16, 146, 241, 359, 393, 541, 602, 649, 688, 701],
            "max3": [152, 281, 292, 344, 628, 673, 743, 777, 792, 994],
            "max4": [48, 126, 129, 332, 780, 787, 874, 908, 918, 923],
            "max5": [182, 204, 252, 457, 522, 578, 652, 660, 685, 705,
                     736, 832, 988],
            "max6": [112, 230, 340, 356, 444, 452, 471, 607, 621, 631,
                     761, 773, 873, 876, 982],
            "max7": [8, 14, 32, 58, 108, 213, 233, 243, 274, 405, 454,
                     614, 653, 683, 728, 732, 770, 795, 803, 826, 867, 949],
            "max8": [5, 178, 188, 202, 337, 378, 406, 461, 539, 696,
                     702, 854, 966, 971],
            "max9": [68, 121, 149, 165, 171, 206, 287, 370, 493, 499,
                     516, 637, 655, 656, 672, 706, 766, 817, 922, 959, 997],
            "max10": [28, 156, 177, 238, 402, 545, 546, 553, 559, 589,
                      591, 725, 764, 791, 810, 844, 858, 868, 972, 977],
        },
    },
}

GAMMA_DOPPLER_PATTERNS = {
    "★ Bayonet | Gamma Doppler": {
        "emerald": [273, 353, 3, 902, 760, 23, 162, 187, 189, 226, 269, 624, 916, 955, 2, 34, 57, 63, 97, 118, 142, 145, 179, 187, 189, 222, 256, 271, 276, 277, 298, 387, 445, 532, 549, 568, 630, 633, 665, 667, 693, 719, 725, 801, 851, 860, 863, 924, 931, 942, 955, 977],  
    },
    "★ Flip Knife | Gamma Doppler": {
        "emerald": [2, 6, 8, 640, 677, 711, 717, 978, 945, 960, 977, 731, 933, 929, 917, 912, 902, 859, 899, 871, 894, 829, 857, 856, 855, 850, 839, 772, 827, 821, 814, 801, 800, 791, 779, 733, 762, 735, 755, 743, 727, 729, 722, 716, 714, 715, 712, 707, 697, 706, 705, 687, 681, 651, 17, 48, 622, 635, 616, 518, 606, 614, 608, 605, 593, 598, 594, 542, 584, 566, 552, 561, 546, 551, 531, 545, 527, 524, 447, 492, 505, 509, 502, 490, 501, 481, 488, 485, 478, 66, 157, 432, 438, 436, 411, 429, 426, 400, 408, 205, 401, 397, 393, 376, 374, 363, 371, 360, 362, 348, 356, 311, 343, 337, 333, 331, 312, 319, 300, 285, 298, 296, 297, 216, 278, 284, 251, 280, 264, 261, 262, 252, 227, 239, 247, 233, 213, 204, 202, 191, 197, 194, 170, 176, 181, 172, 166, 156, 161, 153, 151, 150, 143, 101, 135, 123, 142, 104, 120, 72, 102, 87, 99, 98, 89, 86, 88, 76, 51, 43, 39, 20],
    },
    "★ Gut Knife | Gamma Doppler": {
        "emerald": [3, 4, 14, 17, 20, 24, 26, 30, 33, 39, 46, 62, 78, 85, 88, 89, 92, 99, 101, 106, 112, 113, 114, 117, 133, 135, 137, 153, 157, 158, 160, 177, 180, 182, 186, 188, 190, 192, 197, 198, 202, 208, 209, 212, 221, 228, 230, 244, 245, 250, 267, 268, 274, 284, 293, 294, 306, 307, 309, 313, 317, 320, 321, 325, 333, 339, 343, 344, 346, 352, 356, 359, 369, 370, 371, 388, 396, 398, 399, 405, 407, 412, 416, 417, 422, 423, 436, 437, 440, 442, 443, 453, 467, 470, 472, 483, 490, 492, 494, 500, 507, 510, 517, 524, 525, 527, 528, 529, 532, 533, 535, 536, 540, 549, 552, 554, 555, 557, 560, 566, 568, 577, 578, 579, 584, 589, 592, 594, 598, 605, 611, 639, 650, 651, 656, 660, 672, 679, 692, 701, 718, 726, 730, 732, 737, 741, 743, 748, 765, 771, 772, 779, 780, 796, 802, 806, 808, 828, 829, 832, 836, 841, 845, 853, 855, 862, 869, 873, 875, 887, 890, 905, 918, 924, 928, 935, 944, 950, 952, 958, 960, 963, 966, 967, 970, 973, 981, 991, 994, 995, 997],
    },
    "★ Karambit | Gamma Doppler": {
        "emerald": [610, 425, 315, 88, 907, 311, 243, 113, 767, 606, 98, 746, 812, 783, 42, 190, 419, 432, 630, 594, 680, 220, 972, 387, 547, 899, 785, 445, 865, 607, 683, 102, 143, 59, 209, 822, 269, 290, 954, 962, 4, 7, 39, 60, 86, 106, 110, 116, 125, 132, 151, 185, 194, 196, 202, 218, 222, 226, 253, 325, 328, 354, 360, 374, 383, 384, 422, 436, 478, 480, 487, 507, 540, 551, 555, 560, 560, 570, 598, 621, 646, 659, 667, 678, 681, 693, 694, 696, 711, 717, 750, 756, 770, 776, 777, 819, 843, 858, 859, 868, 871, 894, 896, 908, 922, 969, 983, 20, 31, 45, 49, 58, 66, 77, 119, 132, 149, 153, 160, 162, 166, 174, 178, 184, 189, 192, 193, 203, 204, 217, 234, 246, 250, 262, 280, 286, 287, 292, 296, 303, 334, 369, 370, 373, 388, 394, 404, 409, 411, 412, 423, 443, 444, 450, 463, 464, 468, 469, 477, 489, 492, 498, 502, 504, 506, 510, 526, 530, 532, 574, 579, 580, 589, 593, 600, 616, 627, 637, 670, 699, 705, 706, 716, 723, 730, 733, 764, 766, 787, 795, 803, 817, 818, 844, 853, 857, 861, 874, 893, 913, 928, 935, 939, 949, 992, 998],
    },
    "★ M9 Bayonet | Gamma Doppler": {
        "emerald": [609, 965, 344, 671, 92, 180, 241, 393, 420, 671, 923, 985, 87, 126, 242, 256, 474, 575, 682, 827, 936, 961],
    },
    "★ Huntsman Knife | Gamma Doppler": {
        "emerald": [2, 915, 939, 974, 951, 935, 932, 249, 881, 883, 751, 870, 864, 800, 804, 777, 757, 712, 724, 726, 749, 717, 617, 706, 692, 640, 668, 632, 589, 610, 605, 592, 580, 578, 567, 557, 567, 559, 502, 537, 532, 529, 453, 457, 462, 442, 410, 426, 437, 432, 427, 409, 365, 393, 392, 372, 369, 349, 18, 350, 329, 346, 332, 322, 321, 320, 299, 312, 306, 291, 273, 276, 266, 261, 251, 244, 243, 42, 217, 212, 210, 202, 199, 159, 193, 190, 177, 61, 67, 156, 98, 125, 96, 94, 85, 69, 66, 51, 38, 30],
    },
    "★ Falchion Knife | Gamma Doppler": {
        "emerald": [23, 27, 31, 34, 37, 47, 60, 63, 66, 82, 91, 95, 103, 121, 139, 156, 953, 992, 967, 985, 181, 942, 869, 929, 901, 907, 895, 879, 885, 883, 738, 844, 853, 850, 839, 835, 823, 821, 815, 765, 774, 776, 748, 760, 735, 725, 666, 723, 699, 686, 193, 659, 631, 642, 653, 635, 628, 589, 616, 610, 542, 541, 523, 530, 364, 517, 516, 506, 515, 510, 416, 474, 440, 419, 417, 380, 211, 301, 377, 334, 357, 340, 329, 327, 246, 325, 263, 295, 266, 293, 241, 223, 209, 207, 202, 150, 171, 164],
    },
    "★ Bowie Knife | Gamma Doppler": {
        "emerald": [13, 29, 36, 50, 256, 345, 347, 597, 605, 951, 967, 993, 998, 987, 972, 970, 956, 702, 949, 943, 938, 919, 924, 860, 905, 877, 883, 870, 829, 854, 814, 804, 770, 803, 779, 775, 739, 764, 639, 691, 685, 686, 676, 642, 667, 619, 659, 594, 578, 591, 540, 527, 530, 525, 500, 489, 476, 484, 372, 468, 465, 454, 411, 438, 426, 407, 363, 369, 344, 362, 303, 343, 311, 334, 314, 324, 283, 262, 189, 199, 221, 254, 248, 238, 192, 155, 158, 63, 81, 118, 144, 140, 128, 96, 72],
    },
    "★ Butterfly Knife | Gamma Doppler": {
        "emerald": [29, 36, 53, 72, 121, 134, 291, 422, 467, 494, 576, 583, 602, 630, 651, 664, 681, 701, 703, 704, 788, 793, 806, 807, 832, 897, 6, 15, 30, 41, 44, 55, 56, 59, 86, 110, 126, 128, 135, 136, 147, 151, 155, 159, 184, 241, 262, 300, 338, 362, 398, 401, 428, 445, 460, 491, 623, 683, 696, 762, 910, 946, 966, 4, 11, 12, 14, 22, 31, 43, 50, 66, 82, 84, 90, 94, 105, 132, 137, 144, 211, 221, 286, 342, 348, 350, 360, 361, 389, 393, 440, 456, 466, 468, 492, 503, 557, 560, 566, 588, 589, 591, 626, 628, 636, 645, 692, 697, 708, 712, 717, 720, 721, 799, 816, 870, 871, 874, 875, 877, 880, 895, 911, 913, 925, 928, 951, 952, 961, 962, 965, 993, 997],
    },
    "★ Shadow Daggers | Gamma Doppler": {
        "emerald": [22, 29, 37, 52, 71, 104, 722, 748, 975, 882, 963, 921, 957, 955, 940, 914, 907, 859, 873, 863, 827, 858, 834, 752, 800, 810, 795, 791, 789, 788, 787, 770, 711, 617, 694, 709, 702, 699, 697, 664, 692, 669, 638, 651, 649, 635, 629, 633, 621, 618, 450, 608, 589, 571, 538, 557, 569, 560, 558, 516, 524, 527, 504, 513, 458, 482, 486, 483, 464, 389, 456, 430, 426, 427, 147, 358, 367, 286, 366, 347, 325, 317, 292, 163, 239, 280, 265, 250, 249, 202, 223, 192, 180, 183, 171, 182, 173, 159, 165, 156, 107, 131, 100, 74, 97, 79, 82, 61, 72, 55, 41],
    },
}

RARE_PATTERNS = {
    # Five-SeveN | Kami rare patterns
    "Five-SeveN | Kami": {
        "tier_1": {90, 204, 906, 909, 590, 662},
    },
}


def get_blue_gem_tier(knife_name: str, pattern_id: int) -> Optional[int]:
    """
    Look up the Blue Gem tier for a given knife base name and pattern ID.
    knife_name is expected to be the base name, e.g. '★ Flip Knife | Case Hardened'.
    """
    tiers = BLUE_GEM_PATTERNS.get(knife_name)
    if not tiers:
        return None
    for tier, ids in tiers.items():
        if pattern_id in ids:
            return tier
    return None

def get_doppler_tier(knife_name: str, pattern_id: int) -> Tuple[Optional[str], Optional[int]]:
    """
    Look up the Doppler finish + tier for a given knife base name and pattern ID.
    knife_name is expected to be the base name, e.g. '★ Bayonet | Doppler'.

    Returns (finish_name, tier) where:
      - finish_name is 'Ruby', 'Sapphire' or 'Phase 2'
      - tier is 1/2/3
      - if not found, returns (None, None)
    """
    knife_entry = DOPPLER_PATTERNS.get(knife_name)
    if not knife_entry:
        return None, None

    finish_label_map = {
        "ruby": "Ruby",
        "sapphire": "Sapphire",
        "phase2": "Phase 2",
    }

    for finish_key, finish_label in finish_label_map.items():
        finish_block = knife_entry.get(finish_key, {})
        for tier_num in (1, 2, 3):
            patterns = finish_block.get(f"tier{tier_num}", []) or []
            if pattern_id in patterns:
                return finish_label, tier_num

    return None, None

def get_marble_fade_info(knife_name: str, pattern_id: int) -> Tuple[Optional[str], Optional[int]]:
    """
    Look up the Marble Fade Fire & Ice category + rank for a given knife base name and pattern ID.
    knife_name is expected to be the base name, e.g. '★ Bayonet | Marble Fade'.

    Returns (category, rank):
      - category: 'Fire & Ice', 'Fake Fire & Ice', 'Max Fake Fire & Ice'
      - rank: 1..10 for Fire & Ice max ranks, or None for fake categories
    """
    knife_entry = MARBLE_FADE_PATTERNS.get(knife_name)
    if not knife_entry:
        return None, None

    # True Fire & Ice (max1..max10)
    fi_block = knife_entry.get("fire_and_ice", {})
    for rank in range(1, 11):
        seeds = fi_block.get(f"max{rank}", []) or []
        if pattern_id in seeds:
            return "Fire & Ice", rank

    # Max Fake Fire & Ice
    max_fake = knife_entry.get("max_fake", []) or []
    if pattern_id in max_fake:
        return "Max Fake Fire & Ice", None

    # Fake Fire & Ice
    fake_fi = knife_entry.get("fake_fire_and_ice", []) or []
    if pattern_id in fake_fi:
        return "Fake Fire & Ice", None

    return None, None

def get_gamma_emerald_flag(knife_name: str, pattern_id: int) -> bool:
    """
    Returns True if this knife & pattern is a Gamma Doppler Emerald.
    """
    knife_entry = GAMMA_DOPPLER_PATTERNS.get(knife_name)
    if not knife_entry:
        return False

    emerald_list = knife_entry.get("emerald", []) or []
    return pattern_id in emerald_list

def get_rare_pattern_tier(skin_name: str, pattern_id: int) -> Optional[int]:
    """
    Look up the rare pattern tier for a given skin (e.g. 'Five-SeveN | Kami')
    using the RARE_PATTERNS mapping.

    Returns an integer tier (1, 2, ...) or None if not found.
    """
    entry = RARE_PATTERNS.get(skin_name)
    if not entry:
        return None

    for tier_label, seeds in entry.items():
        if pattern_id in seeds:
            # Expect labels like 'tier_1', 'tier_2', etc.
            if tier_label.startswith("tier_"):
                try:
                    return int(tier_label.split("_", 1)[1])
                except (ValueError, IndexError):
                    pass
            # Fallback: if label format is weird, just call it Tier 1
            return 1

    return None


# --------- 2. Data model ---------

@dataclass
class Listing:
    knife_name: str
    exterior: str
    is_stattrak: bool
    listing_id: str
    price: float
    currency: str
    float_value: Optional[float]
    pattern_id: Optional[int]
    inspect_link: Optional[str]
    market_url: str
    tier: Optional[int] = None               # Blue Gem / Doppler tier / F&I rank
    doppler_finish: Optional[str] = None
    marble_category: Optional[str] = None
    is_gamma_emerald: bool = False
    finish_catalog: Optional[int] = None     # paintindex / finish catalog ID

    # CSFloat-wide pricing / profitability (NEW)
    csfloat_skin_floor: Optional[float] = None   # cheapest CSFloat listing for this skin
    profit_ratio: Optional[float] = None         # steam_price / csfloat_floor





# --------- 3. Runtime config ---------

EXTERIORS = [
    "Factory New",
    "Minimal Wear",
    "Field-Tested",
    "Well-Worn",
    "Battle-Scarred",
]

STEAM_CURRENCY_LABEL = "GBP"       # purely for display
LIMIT_PER_COMBO = 5                # how many cheapest listings per (knife, wear, ST flag)
COMBO_SLEEP_SECONDS = 5.0          # pause between combos
CSFLOAT_BASE_URL = "http://localhost:8080/"
CSFLOAT_DELAY_SECONDS = 0.5        # ~1 req/sec per bot
SCAN_SLEEP_SECONDS = 600           # 10 minutes between full scans
TIMEOUT_SLEEP_SECONDS = 100
# --- Currency conversion ---
# CSFloat returns prices in USD. Steam prices in this script are in GBP.
# Provide the USD to GBP rate manually via environment variable.
USD_TO_GBP = 0.76  # Example: 1 USD ≈ 0.76 GBP

#CSFloat MARKET API (for skin-wide floor prices)
CSFLOAT_MARKET_API_BASE = "https://csfloat.com/api/v1"
CSFLOAT_MARKET_TIMEOUT = 1  # seconds
CSFLOAT_API_KEY = "5nJs5BRbsGv02Se2fwWH5POALAi4dp3h"


# Regexes to pull JS variables out of HTML
LISTINGINFO_RE = re.compile(r"var\s+g_rgListingInfo\s*=\s*(\{.*?\});", re.DOTALL)
ASSETS_RE = re.compile(r"var\s+g_rgAssets\s*=\s*(\{.*?\});", re.DOTALL)


# --------- 4. Name builder ---------

def build_market_name(base_name: str, is_stattrak: bool, exterior: str) -> str:
    """Build Steam market hash name, including StatTrak and wear."""
    ex_map = {
        "Factory New": "Factory New",
        "Minimal Wear": "Minimal Wear",
        "Field-Tested": "Field-Tested",
        "Well-Worn": "Well-Worn",
        "Battle-Scarred": "Battle-Scarred",
    }

    name = base_name
    if is_stattrak:
        # "★ Flip Knife | Case Hardened" -> "★ StatTrak™ Flip Knife | Case Hardened"
        if name.startswith("★ "):
            name = "★ StatTrak™ " + name[2:]
        else:
            name = f"StatTrak™ {name}"

    return f"{name} ({ex_map[exterior]})"


# --------- 5. Fetch listings for a given market name (Steam HTML) ---------

def fetch_listings_for_market(
    market_name: str,
    base_knife_name: str,
    limit: int = LIMIT_PER_COMBO
) -> List[Listing]:
    encoded_name = quote(market_name)
    base_page_url = f"https://steamcommunity.com/market/listings/730/{encoded_name}"

    headers = {
        "User-Agent": (
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
            "AppleWebKit/537.36 (KHTML, like Gecko) "
            "Chrome/124.0.0.0 Safari/537.36"
        ),
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.9",
    }

    while True:
        try:
            r = session.get(base_page_url, headers=headers, timeout=10)
        except Exception as e:
            # Network hiccup – keep retrying this combo
            print(f"[!] Network error fetching {market_name}: {e}. Backing off 30s then retrying same combo.")
            time.sleep(30)
            continue

        # Explicit handling for rate limiting
        if r.status_code == 429:
            sleep_time = TIMEOUT_SLEEP_SECONDS * random.uniform(0.5, 2)
            print(f"[!] Steam 429 Too Many Requests for {market_name}. Backing off {sleep_time} then retrying same combo.")
            time.sleep(sleep_time)
            continue

        # Handle 5xx (Steam side errors) – retry this combo
        if 500 <= r.status_code < 600:
            print(f"[!] Steam {r.status_code} Server Error for {market_name}. Backing off 60s then retrying same combo.")
            time.sleep(60)
            continue

        # For other non-OK codes (e.g. 404), treat as "no listings" and move on
        try:
            r.raise_for_status()
        except requests.exceptions.HTTPError as e:
            print(f"[!] HTTP error for {market_name}: {e}. Treating as no listings and skipping this combo.")
            return []

        # If we got here, we have a 2xx response – break out of retry loop
        html = r.text
        break

    m_info = LISTINGINFO_RE.search(html)
    m_assets = ASSETS_RE.search(html)

    if not m_info or not m_assets:
        print(f"[!] Could not find g_rgListingInfo or g_rgAssets in HTML for {market_name}")
        return []

    listinginfo_json = m_info.group(1)
    assets_json = m_assets.group(1)

    try:
        listinginfo = json.loads(listinginfo_json)
        assets_full = json.loads(assets_json)
    except json.JSONDecodeError as e:
        print(f"[!] JSON decode error in HTML for {market_name}: {e}")
        return []

    app_assets = assets_full.get("730") or assets_full.get(730)
    if not isinstance(app_assets, dict):
        print(f"[!] Unexpected assets[730] type for {market_name}: {type(app_assets)}")
        return []

    ctx_assets = app_assets.get("2") or app_assets.get(2)
    if not isinstance(ctx_assets, dict):
        print(f"[!] Unexpected assets[730][2] type for {market_name}: {type(ctx_assets)}")
        return []

    assets_root: Dict[str, dict] = ctx_assets

    if not isinstance(listinginfo, dict):
        print(f"[!] Unexpected g_rgListingInfo type for {market_name}: {type(listinginfo)}")
        return []

    listing_ids = list(listinginfo.keys())[:limit]

    listings: List[Listing] = []

    for listing_id in listing_ids:
        info = listinginfo.get(listing_id)
        if not isinstance(info, dict):
            continue

        asset_ref = info.get("asset", {})
        if not isinstance(asset_ref, dict):
            continue

        asset_id_ref = asset_ref.get("id")
        if not asset_id_ref:
            continue

        asset = assets_root.get(str(asset_id_ref))
        if not isinstance(asset, dict):
            continue

        # Price (cents)
        price_total = info.get("converted_price")
        fee_total = info.get("converted_fee")
        if price_total is None or fee_total is None:
            price_total = info.get("price", 0)
            fee_total = info.get("fee", 0)
        price = (price_total + fee_total) / 100.0

        # Inspect link
        assetid = asset.get("id") or asset.get("assetid")
        assetid = str(assetid) if assetid is not None else None

        inspect_link = None
        market_actions = asset.get("market_actions") or []
        if isinstance(market_actions, list) and market_actions:
            raw_link = market_actions[0].get("link")
            if raw_link and assetid:
                inspect_link = raw_link.replace("%assetid%", assetid)
            else:
                inspect_link = raw_link

        listings.append(
            Listing(
                knife_name=base_knife_name,   # store base name, not the full hash
                exterior="",                  # filled by caller
                is_stattrak="StatTrak™" in market_name,
                listing_id=listing_id,
                price=price,
                currency=STEAM_CURRENCY_LABEL,
                float_value=None,
                pattern_id=None,
                inspect_link=inspect_link,
                market_url=base_page_url,
            )
        )

    return listings




# --------- 6. CSFloat per-item GET ---------

def fetch_float_for_listing(listing: Listing) -> None:
    if not listing.inspect_link:
        print(f"Listing {listing.listing_id}: missing inspect link.")
        return

    params = {"url": listing.inspect_link}

    try:
        r = requests.get(CSFLOAT_BASE_URL, params=params, timeout=10)

        if r.status_code == 429:
            print(f"[!] CSFloat 429 for listing {listing.listing_id}, backing off 3s.")
            time.sleep(3)
            return

        r.raise_for_status()
        data = r.json()

        if "error" in data:
            print(f"[!] CSFloat error for listing {listing.listing_id}: {data}")
            return

        # Most setups wrap in "iteminfo"
        item = data.get("iteminfo")
        src = item if isinstance(item, dict) else data

        float_raw = src.get("floatvalue", src.get("paintwear"))
        paintseed = src.get("paintseed")
        paintindex = src.get("paintindex")  # <-- this is the finish catalog ID

        if float_raw is None or paintseed is None:
            print(f"[!] CSFloat: missing float or paintseed for listing {listing.listing_id}. "
                  f"Raw response: {data}")
            return

        listing.float_value = float(float_raw)
        listing.pattern_id = int(paintseed)

        if paintindex is not None:
            try:
                listing.finish_catalog = int(paintindex)
            except (TypeError, ValueError):
                print(f"[!] CSFloat: unexpected paintindex for listing {listing.listing_id}: {paintindex}")

    except Exception as e:
        print(f"[!] Error calling CSFloat for listing {listing.listing_id}: {e}")



def fetch_float_data_for_listings(listings: List[Listing]) -> None:
    for idx, l in enumerate(listings, start=1):
        print(f"Fetching float for listing {l.listing_id} ({idx}/{len(listings)})...")
        fetch_float_for_listing(l)
        time.sleep(CSFLOAT_DELAY_SECONDS)  # respect ~1 req/sec per bot

# --------- 6b. CSFloat market floor (cheapest listing for this skin) ---------

def fetch_csfloat_skin_floor(market_hash_name: str, is_stattrak: bool) -> Optional[float]:
    """
    Returns the cheapest CSFloat listing price for this skin (any pattern) as a float
    (USD, dollars), or None if no listing / error.
    """
    params = {
        "market_hash_name": market_hash_name,
        "sort_by": "lowest_price",
        "limit": 1,
        "category": 2 if is_stattrak else 1,  # 1=normal, 2=StatTrak
    }

    headers: Dict[str, str] = {}
    if CSFLOAT_API_KEY:
        headers["Authorization"] = CSFLOAT_API_KEY

    try:
        resp = requests.get(
            f"{CSFLOAT_MARKET_API_BASE}/listings",
            params=params,
            headers=headers,
            timeout=CSFLOAT_MARKET_TIMEOUT,
        )
        if resp.status_code != 200:
            print(f"[CSFloat] HTTP {resp.status_code} for {market_hash_name}")
            return None

        payload = resp.json()
        # Debug if you still want:
        # print(payload)

        # CSFloat returns {"data": [...], "cursor": "..."}
        if isinstance(payload, dict):
            listings = payload.get("data") or []
        elif isinstance(payload, list):
            # Fallback in case API ever returns a bare list
            listings = payload
        else:
            listings = []

        if not listings:
            print(f"No active listings for {market_hash_name} on CSFloat")
            return None

        first = listings[0]
        cents = first.get("price")

        # Fallback: in case they ever shift price into a nested "reference"
        if cents is None:
            ref = first.get("reference") or {}
            cents = ref.get("base_price")

        if cents is None:
            print(f"[CSFloat] Could not find price field for {market_hash_name} in {first}")
            return None

        usd_price = float(cents) / 100.0
        gbp_price = usd_price * USD_TO_GBP
        return gbp_price

        # Optional debug:
        # print(f"[CSFloat] Floor for {market_hash_name}: {floor}")
        return floor

    except Exception as e:
        print(f"[CSFloat] Error fetching skin floor for {market_hash_name}: {e}")
        return None



def add_profitability_info(listing: Listing) -> None:
    """
    For a rare hit listing, fetch the CSFloat skin floor and attach a simple
    profitability label to the listing:
      - LIKELY_PROFITABLE: Steam ≤ 20% above CSFloat floor
      - MAYBE: Steam ≤ 50% above CSFloat floor
      - UNLIKELY: Steam > 50% above CSFloat floor
    """
    # Build the full market hash name again (same as the Steam page we hit)
    market_hash_name = build_market_name(listing.knife_name, listing.is_stattrak, listing.exterior)

    floor_price = fetch_csfloat_skin_floor(market_hash_name, listing.is_stattrak)
    listing.csfloat_skin_floor = floor_price

    if floor_price is None or floor_price <= 0 or listing.price <= 0:
        return

    ratio = listing.price / floor_price
    listing.profit_ratio = ratio



# --------- 7. Discord notification ---------

def send_discord_notification(hits: List[Listing]) -> None:
    if not DISCORD_WEBHOOK_URL or DISCORD_WEBHOOK_URL.startswith("PUT_YOUR_"):
        print("[!] Discord webhook URL not set, skipping notification.")
        return

    # Emojis for finishes / rare types
    FINISH_EMOJIS = {
        "Ruby": "❤️",
        "Sapphire": "🔷",
        "Phase 2": "⚡",
        "Blue Gem": "💎",
        "Fire & Ice": "🔥❄️",
        "Fake Fire & Ice": "⚠️❄️",
        "Max Fake Fire & Ice": "⚠️",
        "Emerald": "💚", 
    }


    # Header – generic for all rare patterns
    lines = [f"{DISCORD_MENTION} 💎 **New rare pattern found!**"]

    for h in hits:

        # Identify type + pick emoji + variant string
        if h.doppler_finish:
            # Doppler
            finish_name = h.doppler_finish
            emoji = FINISH_EMOJIS.get(finish_name, "✨")
            variant_str = f"{emoji} {finish_name} Doppler"

        elif "Case Hardened" in h.knife_name:
            # Blue Gem Case Hardened
            emoji = FINISH_EMOJIS["Blue Gem"]
            variant_str = f"{emoji} Blue Gem Case Hardened"

        elif h.marble_category:
            # Marble Fade Fire & Ice (or fake)
            emoji = FINISH_EMOJIS.get(h.marble_category, "🔥❄️")
            variant_str = f"{emoji} {h.marble_category} Marble Fade"

        elif h.is_gamma_emerald:
            emoji = FINISH_EMOJIS["Emerald"]
            variant_str = f"{emoji} Gamma Doppler Emerald"

        elif "Five-SeveN | Kami" in h.knife_name:
            emoji = "📝"
            variant_str = f"{emoji} Five-Seven Kami rare pattern"

        else:
            # Fallback (shouldn't occur realistically)
            emoji = "✨"
            variant_str = f"{emoji} Rare pattern"

        tier_str = f"Tier {h.tier}" if h.tier else "Tier ?"

        if h.profit_ratio is not None:
            profit_line = f"\n  Steam/CSFloat = {h.profit_ratio:.2f}x"
        else:
            profit_line = ""

        lines.append(
            f"- **{h.knife_name}** | {h.exterior} | "
            f"{'StatTrak™' if h.is_stattrak else 'Non-StatTrak'} | "
            f"{variant_str} ({tier_str}) | "
            f"Pattern `{h.pattern_id}` | Float `{h.float_value:.5f}` | "
            f"Price: {h.price:.2f} {h.currency}"
            f"{profit_line}\n"
            f"  <{h.market_url}>"
        )


    content = "\n".join(lines)
    payload = {"content": content}

    try:
        resp = requests.post(DISCORD_WEBHOOK_URL, json=payload, timeout=10)
        if resp.status_code >= 400:
            print(f"[!] Discord webhook error: {resp.status_code} {resp.text}")
        else:
            print("[+] Sent Discord notification.")
    except Exception as e:
        print(f"[!] Failed to send Discord notification: {e}")





# --------- 8. Scan all knives & return hits ---------

def scan_all_case_hardened(limit_per_combo: int = LIMIT_PER_COMBO) -> List[Listing]:
    all_hits: List[Listing] = []

    for base_knife_name in BASE_KNIFE_NAMES:
        for is_stattrak in STATTRAK_FLAGS:
            for exterior in EXTERIORS:
                market_name = build_market_name(base_knife_name, is_stattrak, exterior)
                print(
                    f"\n=== Checking {market_name} "
                    f"({'StatTrak' if is_stattrak else 'non-StatTrak'}, "
                    f"{limit_per_combo} cheapest) ==="
                )

                listings = fetch_listings_for_market(
                    market_name,
                    base_knife_name,
                    limit=limit_per_combo
                )

                # Decorate with context
                for l in listings:
                    l.exterior = exterior
                    l.is_stattrak = is_stattrak

                if not listings:
                    print("No listings found (or Steam blocked the request).")
                    time.sleep(COMBO_SLEEP_SECONDS + random.uniform(1, 3))
                    continue

                # Get floats + patterns
                fetch_float_data_for_listings(listings)

                for l in listings:
                    if l.float_value is None or l.pattern_id is None:
                        print(f"Listing {l.listing_id}: no float/pattern data.")
                        continue

                    tier = get_blue_gem_tier(l.knife_name, l.pattern_id)
                    l.tier = tier

                    if tier:
                        # Only notify if we haven't seen this listing_id before
                        if l.listing_id not in SEEN_HIT_LISTING_IDS:
                            SEEN_HIT_LISTING_IDS.add(l.listing_id)
                            save_seen_hit_ids()  # persist immediately
                            add_profitability_info(l)
                            all_hits.append(l)
                            print(
                                f"[HIT] {l.knife_name} | {l.exterior} | "
                                f"{'StatTrak' if l.is_stattrak else 'Non-StatTrak'} | "
                                f"Tier {tier} Blue Gem | "
                                f"pattern {l.pattern_id} | float {l.float_value:.5f} | "
                                f"{l.price:.2f} {l.currency} | "
                                f"{l.market_url}"
                            )
                            # 🔔 IMMEDIATE notification for this new hit
                            send_discord_notification([l])
                        else:
                            print(
                                f"[SKIP] Already notified for listing {l.listing_id} "
                                f"({l.knife_name} | {l.exterior} | pattern {l.pattern_id})"
                            )
                    else:
                        print(
                            f"Listing {l.listing_id}: {l.knife_name} | {l.exterior} | "
                            f"pattern {l.pattern_id}, float {l.float_value:.5f} – not in top list."
                        )

                # Be kind to Steam between combos
                time.sleep(COMBO_SLEEP_SECONDS + random.uniform(1, 3))

    return all_hits

def classify_doppler(
    knife_name: str,
    pattern_id: int,
    finish_catalog: Optional[int],
) -> Tuple[Optional[str], Optional[int]]:
    """
    Returns (finish_name, tier):

      - finish_name is 'Ruby', 'Sapphire', 'Phase 2', etc. (based on finish_catalog)
      - tier is 1 / 2 / 3 if the pattern is in your DOPPLER_PATTERNS
    """
    finish_name: Optional[str] = None
    tier: Optional[int] = None

    # 1) Decide which finish this is based on the finish catalog ID
    if finish_catalog in DOPPLER_FINISH_BY_CATALOG:
        finish_name = DOPPLER_FINISH_BY_CATALOG[finish_catalog]

    # 2) If we know the finish, try to apply your tier lists using pattern_id
    knife_entry = DOPPLER_PATTERNS.get(knife_name)
    if knife_entry and finish_name:
        # "Ruby" -> "ruby", "Phase 2" -> "phase2"
        finish_key = finish_name.lower().replace(" ", "")
        finish_block = knife_entry.get(finish_key, {})

        for tier_num in (1, 2, 3):
            patterns = finish_block.get(f"tier{tier_num}", []) or []
            if pattern_id in patterns:
                tier = tier_num
                break

    return finish_name, tier


def scan_all_dopplers(limit_per_combo: int = LIMIT_PER_COMBO) -> List[Listing]:
    all_hits: List[Listing] = []

    for base_knife_name in DOPPLER_KNIFE_NAMES:
        for is_stattrak in STATTRAK_FLAGS:
            for exterior in DOPPLER_EXTERIORS:
                market_name = build_market_name(base_knife_name, is_stattrak, exterior)
                print(
                    f"\n=== Checking {market_name} "
                    f"({'StatTrak' if is_stattrak else 'non-StatTrak'}, "
                    f"{limit_per_combo} cheapest) ==="
                )

                listings = fetch_listings_for_market(
                    market_name,
                    base_knife_name,
                    limit=limit_per_combo
                )

                # Decorate with context
                for l in listings:
                    l.exterior = exterior
                    l.is_stattrak = is_stattrak

                if not listings:
                    print("No listings found (or Steam blocked the request).")
                    time.sleep(COMBO_SLEEP_SECONDS + random.uniform(1, 3))
                    continue

                # Get floats + patterns
                fetch_float_data_for_listings(listings)

                for l in listings:
                    if l.float_value is None or l.pattern_id is None:
                        print(f"Listing {l.listing_id}: no float/pattern data.")
                        continue

                    doppler_finish, tier = classify_doppler(
                        l.knife_name,
                        l.pattern_id,
                        l.finish_catalog,
                    )
                    l.tier = tier
                    l.doppler_finish = doppler_finish


                    if tier and doppler_finish:
                        # Only notify if we haven't seen this listing_id before
                        if l.listing_id not in SEEN_HIT_LISTING_IDS:
                            SEEN_HIT_LISTING_IDS.add(l.listing_id)
                            save_seen_hit_ids()  # persist immediately
                            add_profitability_info(l)
                            all_hits.append(l)
                            print(
                                f"[HIT] {l.knife_name} | {l.exterior} | "
                                f"{'StatTrak' if l.is_stattrak else 'Non-StatTrak'} | "
                                f"{doppler_finish} Doppler | Tier {tier} | "
                                f"pattern {l.pattern_id} | float {l.float_value:.5f} | "
                                f"{l.price:.2f} {l.currency} | "
                                f"{l.market_url}"
                            )
                            # 🔔 IMMEDIATE notification for this new hit
                            send_discord_notification([l])
                        else:
                            print(
                                f"[SKIP] Already notified for listing {l.listing_id} "
                                f"({l.knife_name} | {l.exterior} | pattern {l.pattern_id})"
                            )
                    else:
                        print(
                            f"Listing {l.listing_id}: {l.knife_name} | {l.exterior} | "
                            f"pattern {l.pattern_id}, finish catalog {l.finish_catalog}, float {l.float_value:.5f} – not in Doppler top list."
                        )

                # Be kind to Steam between combos
                time.sleep(COMBO_SLEEP_SECONDS + random.uniform(1, 3))

    return all_hits

def scan_all_marble_fade(limit_per_combo: int = LIMIT_PER_COMBO) -> List[Listing]:
    all_hits: List[Listing] = []

    for base_knife_name in MARBLE_FADE_KNIFE_NAMES:
        for is_stattrak in STATTRAK_FLAGS:
            for exterior in MARBLE_FADE_EXTERIORS:
                market_name = build_market_name(base_knife_name, is_stattrak, exterior)
                print(
                    f"\n=== Checking {market_name} "
                    f"({'StatTrak' if is_stattrak else 'non-StatTrak'}, "
                    f"{limit_per_combo} cheapest) ==="
                )

                listings = fetch_listings_for_market(
                    market_name,
                    base_knife_name,
                    limit=limit_per_combo
                )

                # Decorate with context
                for l in listings:
                    l.exterior = exterior
                    l.is_stattrak = is_stattrak

                if not listings:
                    print("No listings found (or Steam blocked the request).")
                    time.sleep(COMBO_SLEEP_SECONDS + random.uniform(1, 3))
                    continue

                # Get floats + patterns
                fetch_float_data_for_listings(listings)

                for l in listings:
                    if l.float_value is None or l.pattern_id is None:
                        print(f"Listing {l.listing_id}: no float/pattern data.")
                        continue

                    category, rank = get_marble_fade_info(l.knife_name, l.pattern_id)
                    l.marble_category = category
                    l.tier = rank  # use tier for F&I rank (1..10) if present

                    if category:
                        # Only notify if we haven't seen this listing_id before
                        if l.listing_id not in SEEN_HIT_LISTING_IDS:
                            SEEN_HIT_LISTING_IDS.add(l.listing_id)
                            save_seen_hit_ids()  # persist immediately
                            add_profitability_info(l)
                            all_hits.append(l)
                            rank_str = f"Rank {rank}" if rank else "Unranked"
                            print(
                                f"[HIT] {l.knife_name} | {l.exterior} | "
                                f"{'StatTrak' if l.is_stattrak else 'Non-StatTrak'} | "
                                f"{category} | {rank_str} | "
                                f"pattern {l.pattern_id} | float {l.float_value:.5f} | "
                                f"{l.price:.2f} {l.currency} | "
                                f"{l.market_url}"
                            )
                            # 🔔 IMMEDIATE notification for this new hit
                            send_discord_notification([l])
                        else:
                            print(
                                f"[SKIP] Already notified for listing {l.listing_id} "
                                f"({l.knife_name} | {l.exterior} | pattern {l.pattern_id})"
                            )
                    else:
                        print(
                            f"Listing {l.listing_id}: {l.knife_name} | {l.exterior} | "
                            f"pattern {l.pattern_id}, float {l.float_value:.5f} – not in Marble Fade F&I list."
                        )

                # Be kind to Steam between combos
                time.sleep(COMBO_SLEEP_SECONDS + random.uniform(1, 3))

    return all_hits

def scan_all_gamma_doppler(limit_per_combo: int = LIMIT_PER_COMBO) -> List[Listing]:
    all_hits: List[Listing] = []

    for base_knife_name in GAMMA_DOPPLER_KNIFE_NAMES:
        for is_stattrak in STATTRAK_FLAGS:
            for exterior in GAMMA_DOPPLER_EXTERIORS:
                market_name = build_market_name(base_knife_name, is_stattrak, exterior)
                print(
                    f"\n=== Checking {market_name} "
                    f"({'StatTrak' if is_stattrak else 'non-StatTrak'}, "
                    f"{limit_per_combo} cheapest) ==="
                )

                listings = fetch_listings_for_market(
                    market_name,
                    base_knife_name,
                    limit=limit_per_combo
                )

                for l in listings:
                    l.exterior = exterior
                    l.is_stattrak = is_stattrak

                if not listings:
                    print("No listings found (or Steam blocked the request).")
                    time.sleep(COMBO_SLEEP_SECONDS + random.uniform(1, 3))
                    continue

                fetch_float_data_for_listings(listings)

                for l in listings:
                    if l.float_value is None or l.pattern_id is None:
                        print(f"Listing {l.listing_id}: no float/pattern data.")
                        continue

                    is_emerald = (l.finish_catalog == 568)
                    l.is_gamma_emerald = is_emerald

                    if is_emerald:
                        if l.listing_id not in SEEN_HIT_LISTING_IDS:
                            SEEN_HIT_LISTING_IDS.add(l.listing_id)
                            save_seen_hit_ids()
                            add_profitability_info(l)
                            all_hits.append(l)
                            print(
                                f"[HIT] {l.knife_name} | {l.exterior} | "
                                f"{'StatTrak' if l.is_stattrak else 'Non-StatTrak'} | "
                                f"Gamma Doppler Emerald | "
                                f"pattern {l.pattern_id} | float {l.float_value:.5f} | "
                                f"{l.price:.2f} {l.currency} | {l.market_url}"
                            )

                            send_discord_notification([l])
                        else:
                            print(f"[SKIP] Already notified for listing {l.listing_id}")
                    else:
                        print(
                            f"Listing {l.listing_id}: pattern {l.pattern_id} finish catalog {l.finish_catalog} float {l.float_value:.5f} "
                            f"– not an Emerald."
                        )

                time.sleep(COMBO_SLEEP_SECONDS + random.uniform(1, 3))

    return all_hits

def scan_all_kami(limit_per_combo: int = LIMIT_PER_COMBO) -> List[Listing]:
    """
    Scan Five-SeveN | Kami for rare pattern IDs defined in RARE_PATTERNS.
    Works for all exteriors and (optionally) StatTrak depending on STATTRAK_FLAGS.
    """
    all_hits: List[Listing] = []
    base_skin_name = "Five-SeveN | Kami"

    for is_stattrak in STATTRAK_FLAGS:
        for exterior in EXTERIORS:
            market_name = build_market_name(base_skin_name, is_stattrak, exterior)
            print(
                f"\n=== Checking {market_name} "
                f"({'StatTrak' if is_stattrak else 'non-StatTrak'}, "
                f"{limit_per_combo} cheapest) ==="
            )

            listings = fetch_listings_for_market(
                market_name,
                base_skin_name,
                limit=limit_per_combo
            )

            # Decorate with context
            for l in listings:
                l.exterior = exterior
                l.is_stattrak = is_stattrak

            if not listings:
                print("No listings found (or Steam blocked the request).")
                time.sleep(COMBO_SLEEP_SECONDS + random.uniform(1, 3))
                continue

            # Get floats + patterns
            fetch_float_data_for_listings(listings)

            for l in listings:
                if l.float_value is None or l.pattern_id is None:
                    print(f"Listing {l.listing_id}: no float/pattern data.")
                    continue

                tier = get_rare_pattern_tier(base_skin_name, l.pattern_id)
                l.tier = tier

                if tier:
                    # Only notify if we haven't seen this listing_id before
                    if l.listing_id not in SEEN_HIT_LISTING_IDS:
                        SEEN_HIT_LISTING_IDS.add(l.listing_id)
                        save_seen_hit_ids()  # persist immediately
                        add_profitability_info(l)
                        all_hits.append(l)
                        print(
                            f"[HIT] {l.knife_name} | {l.exterior} | "
                            f"{'StatTrak' if l.is_stattrak else 'Non-StatTrak'} | "
                            f"Tier {tier} Kami rare pattern | "
                            f"pattern {l.pattern_id} | float {l.float_value:.5f} | "
                            f"{l.price:.2f} {l.currency} | "
                            f"{l.market_url}"
                        )
                        # 🔔 IMMEDIATE notification for this new hit
                        send_discord_notification([l])
                    else:
                        print(
                            f"[SKIP] Already notified for listing {l.listing_id} "
                            f"({l.knife_name} | {l.exterior} | pattern {l.pattern_id})"
                        )
                else:
                    print(
                        f"Listing {l.listing_id}: {l.knife_name} | {l.exterior} | "
                        f"pattern {l.pattern_id}, float {l.float_value:.5f} – not a Kami rare pattern."
                    )

            # Be kind to Steam between combos
            time.sleep(COMBO_SLEEP_SECONDS + random.uniform(1, 3))

    return all_hits

def main_scan():
        # 1) Case Hardened Blue Gems
        hits_ch = scan_all_case_hardened(limit_per_combo=LIMIT_PER_COMBO)

        # 2) Gamma Doppler Emerald
        hits_gd = scan_all_gamma_doppler(limit_per_combo=LIMIT_PER_COMBO)

        # 3) Case Hardened Blue Gems
        hits_ch2 = scan_all_case_hardened(limit_per_combo=LIMIT_PER_COMBO)

        # 4) Doppler Rubies / Sapphires / Phase 2
        hits_doppler = scan_all_dopplers(limit_per_combo=LIMIT_PER_COMBO)

        # 5) Case Hardened Blue Gems
        hits_ch3 = scan_all_case_hardened(limit_per_combo=LIMIT_PER_COMBO)

        # 6) Marble Fade Fire & Ice
        hits_mf = scan_all_marble_fade(limit_per_combo=LIMIT_PER_COMBO)

        # 7) Case Hardened Blue Gems
        hits_ch4 = scan_all_case_hardened(limit_per_combo=LIMIT_PER_COMBO)

        # 8) Five-Seven Kami
        SCAN_STATTRAK = os.getenv("SCAN_STATTRAK", "0") == "1"
        STATTRAK_FLAGS = [False, True] if SCAN_STATTRAK else [False]
        STATTRAK_FLAGS_SAVE = STATTRAK_FLAGS
        STATTRAK_FLAGS = [False, True]
        hits_kami = scan_all_kami(limit_per_combo=10)
        STATTRAK_FLAGS = STATTRAK_FLAGS_SAVE

        total_hits = (
            len(hits_ch) + len(hits_ch2) + len(hits_ch3) + len(hits_ch4) +
            len(hits_gd) + len(hits_doppler) +
            len(hits_mf) + len(hits_kami)
        )

        print(f"[i] Run #{run_count} complete, total new hits this run: {total_hits}")

        random_scan_sleep_seconds = SCAN_SLEEP_SECONDS * random.uniform(0.5, 2)
        print(f"[i] Sleeping {random_scan_sleep_seconds} seconds before next run...\n")
        time.sleep(random_scan_sleep_seconds)

# --------- 9. Entry point: run indefinitely ---------

if __name__ == "__main__":
    # Load previously-seen listing IDs from disk
    load_seen_hit_ids()

    run_count = 0
    while True:
        run_count += 1
        print(f"\n============================")
        print(f"   SCAN RUN #{run_count}")
        print(f"============================")

        SCAN_STATTRAK = os.getenv("SCAN_STATTRAK", "0") == "1"
        STATTRAK_FLAGS = [False, True] if SCAN_STATTRAK else [False]

        STATTRAK_FLAGS_SAVE = STATTRAK_FLAGS
        STATTRAK_FLAGS = [False, True]
        main_scan()
        STATTRAK_FLAGS = STATTRAK_FLAGS_SAVE

        for i in range(4):
            main_scan()


